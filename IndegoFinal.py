# -*- coding: utf-8 -*-
"""192 Final Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EZaMV24uIoJheJ4TiwSo85-9MEa4vnbq

https://www.rideindego.com/about/data/

Doing 2021 Q1 Jan - March
"""

import pandas as pd
from math import cos, sin, asin, sqrt, pi, isnan

# class describes each location of a station
class Location:
  def __init__(self, stationNum, frequency, lat, lon): # input most popular bikes maybe
    self.station = stationNum
    self.freq = frequency
    self.lat = lat
    self.lon = lon

  def __str__(self): # string representation
    location = (self.lat, self.lon)
    return 'station:'+str(self.station)+' location:'+str(location)+' frequency:'+str(self.freq)

  def __ge__(self, other): # finds if this location is more popular than other
    return self.freq >= other.freq

  def __eq__(self, other): # check if two stations are equal
    return self.station == other.station

  def distance(self, new_lat, new_lon): # finds distance between this location and other location
    radians = pi / 180
    hav = 0.5 - cos((new_lat-self.lat) * radians) / 2 
    hav2 = cos(self.lat*radians) * cos(new_lat*radians) * (1-cos((new_lon-self.lon)*radians)) / 2
    return 2 * 6378 * asin(sqrt(hav + hav2)) # in km

# maps station to frequency, returns a tuple of two dicts
def getDictFreq(cs): 
  freqStart = dict() 
  listStart = list()
  listEnd = list()
  freqEnd = dict()

  timeFreq = dict() # maps station to a list of times travelled
  for index, row in cs.iterrows():
    stationCol = row['start_station']
    start_lat = row['start_lat']
    start_lon = row['start_lon']
    start_tup = (stationCol, start_lat, start_lon)

    # start location
    if not isnan(start_lat) and not isnan(start_lon): # avoid empty cells
      if stationCol not in listStart: # initial key/value pair to dict
        freqStart[start_tup] = 1
        listStart.append(stationCol)
      else:
        freqStart[start_tup] += 1
      
    # end location
    endStation = row['end_station']
    end_lat = row['end_lat']
    end_lon = row['end_lon']
    end_tup = (endStation, end_lat, end_lon)
    if not isnan(end_lat) and not isnan(end_lon):
      if endStation not in listEnd: # initial key/value pair to dict
        freqEnd[end_tup] = 1
        listEnd.append(endStation)
      else:
        freqEnd[end_tup] += 1
    
  tup = (freqStart, freqEnd)
  return tup

# sort by frequency of value in descending order
def sort_dict(d): 
  result = list()
  for key in d:
    entry = (key, d[key])
    result.append(entry)
  result.sort(reverse=True, key=lambda x: x[1])
  return result 

def main():
  curr_csv = pd.read_csv('indego-trips-2021-q1.csv')
  curr_tup = getDictFreq(curr_csv)

  # lists map station to frequency in descending order
  # format: list of tuples: ((station, lat, lon), frequency)
  # both lists' lengths should be equal
  startList = sort_dict(curr_tup[0])
  endList = sort_dict(curr_tup[1])

  mostPopular = Location(stationNum=startList[0][0][0], frequency=startList[0][1], 
                         lat=startList[0][0][1], lon=startList[0][0][2])
  
  # from the most popular station, compute average distances/etc


  # testing stuff, delete when done
  test = Location(stationNum=startList[0][0][0], frequency=startList[0][1], lat=startList[0][0][1], 
                  lon=startList[0][0][2])
  test2 = Location(stationNum=startList[1][0][0], frequency=startList[1][1], lat=startList[1][0][1], 
                  lon=startList[1][0][2])
  print(str(test))
  print(str(test2))
  print(test2.distance(test.lat, test.lon))
  print(test2 >= test)
  print(test2 <= test)

if __name__ == '__main__':
  main()

